{"ast":null,"code":"import _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _excluded = [\"onRecordingError\", \"onRecordingFinished\"],\n  _excluded2 = [\"device\", \"frameProcessor\", \"frameProcessorFps\"];\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport React from 'react';\nimport { requireNativeComponent } from \"react-native-web/dist/index\";\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nimport findNodeHandle from \"react-native-web/dist/exports/findNodeHandle\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport { CameraCaptureError, CameraRuntimeError, tryParseNativeCameraError, isErrorWithCause } from \"./CameraError\";\nvar CameraModule = NativeModules.CameraView;\nif (CameraModule == null) console.error(\"Camera: Native Module 'CameraView' was null! Did you run pod install?\");\nexport var Camera = function (_React$PureComponent) {\n  _inherits(Camera, _React$PureComponent);\n  var _super = _createSuper(Camera);\n  function Camera(props) {\n    var _this;\n    _classCallCheck(this, Camera);\n    _this = _super.call(this, props);\n    _defineProperty(_assertThisInitialized(_this), \"displayName\", Camera.displayName);\n    _defineProperty(_assertThisInitialized(_this), \"lastFrameProcessor\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"isNativeViewMounted\", false);\n    _defineProperty(_assertThisInitialized(_this), \"ref\", void 0);\n    _this.onViewReady = _this.onViewReady.bind(_assertThisInitialized(_this));\n    _this.onInitialized = _this.onInitialized.bind(_assertThisInitialized(_this));\n    _this.onError = _this.onError.bind(_assertThisInitialized(_this));\n    _this.onFrameProcessorPerformanceSuggestionAvailable = _this.onFrameProcessorPerformanceSuggestionAvailable.bind(_assertThisInitialized(_this));\n    _this.ref = React.createRef();\n    _this.lastFrameProcessor = undefined;\n    return _this;\n  }\n  _createClass(Camera, [{\n    key: \"handle\",\n    get: function get() {\n      var nodeHandle = findNodeHandle(this.ref.current);\n      if (nodeHandle == null || nodeHandle === -1) {\n        throw new CameraRuntimeError('system/view-not-found', \"Could not get the Camera's native view tag! Does the Camera View exist in the native view-tree?\");\n      }\n      return nodeHandle;\n    }\n  }, {\n    key: \"takePhoto\",\n    value: function () {\n      var _takePhoto = _asyncToGenerator(function* (options) {\n        try {\n          return yield CameraModule.takePhoto(this.handle, options !== null && options !== void 0 ? options : {});\n        } catch (e) {\n          throw tryParseNativeCameraError(e);\n        }\n      });\n      function takePhoto(_x) {\n        return _takePhoto.apply(this, arguments);\n      }\n      return takePhoto;\n    }()\n  }, {\n    key: \"takeSnapshot\",\n    value: function () {\n      var _takeSnapshot = _asyncToGenerator(function* (options) {\n        if (Platform.OS !== 'android') throw new CameraCaptureError('capture/capture-type-not-supported', \"'takeSnapshot()' is not available on \" + Platform.OS + \"!\");\n        try {\n          return yield CameraModule.takeSnapshot(this.handle, options !== null && options !== void 0 ? options : {});\n        } catch (e) {\n          throw tryParseNativeCameraError(e);\n        }\n      });\n      function takeSnapshot(_x2) {\n        return _takeSnapshot.apply(this, arguments);\n      }\n      return takeSnapshot;\n    }()\n  }, {\n    key: \"startRecording\",\n    value: function startRecording(options) {\n      var onRecordingError = options.onRecordingError,\n        onRecordingFinished = options.onRecordingFinished,\n        passThroughOptions = _objectWithoutProperties(options, _excluded);\n      if (typeof onRecordingError !== 'function' || typeof onRecordingFinished !== 'function') throw new CameraRuntimeError('parameter/invalid-parameter', 'The onRecordingError or onRecordingFinished functions were not set!');\n      var onRecordCallback = function onRecordCallback(video, error) {\n        if (error != null) return onRecordingError(error);\n        if (video != null) return onRecordingFinished(video);\n      };\n      try {\n        CameraModule.startRecording(this.handle, passThroughOptions, onRecordCallback);\n      } catch (e) {\n        throw tryParseNativeCameraError(e);\n      }\n    }\n  }, {\n    key: \"pauseRecording\",\n    value: function () {\n      var _pauseRecording = _asyncToGenerator(function* () {\n        try {\n          return yield CameraModule.pauseRecording(this.handle);\n        } catch (e) {\n          throw tryParseNativeCameraError(e);\n        }\n      });\n      function pauseRecording() {\n        return _pauseRecording.apply(this, arguments);\n      }\n      return pauseRecording;\n    }()\n  }, {\n    key: \"resumeRecording\",\n    value: function () {\n      var _resumeRecording = _asyncToGenerator(function* () {\n        try {\n          return yield CameraModule.resumeRecording(this.handle);\n        } catch (e) {\n          throw tryParseNativeCameraError(e);\n        }\n      });\n      function resumeRecording() {\n        return _resumeRecording.apply(this, arguments);\n      }\n      return resumeRecording;\n    }()\n  }, {\n    key: \"stopRecording\",\n    value: function () {\n      var _stopRecording = _asyncToGenerator(function* () {\n        try {\n          return yield CameraModule.stopRecording(this.handle);\n        } catch (e) {\n          throw tryParseNativeCameraError(e);\n        }\n      });\n      function stopRecording() {\n        return _stopRecording.apply(this, arguments);\n      }\n      return stopRecording;\n    }()\n  }, {\n    key: \"focus\",\n    value: function () {\n      var _focus = _asyncToGenerator(function* (point) {\n        try {\n          return yield CameraModule.focus(this.handle, point);\n        } catch (e) {\n          throw tryParseNativeCameraError(e);\n        }\n      });\n      function focus(_x3) {\n        return _focus.apply(this, arguments);\n      }\n      return focus;\n    }()\n  }, {\n    key: \"getAvailableVideoCodecs\",\n    value: function () {\n      var _getAvailableVideoCodecs = _asyncToGenerator(function* (fileType) {\n        if (Platform.OS !== 'ios') return [];\n        try {\n          return yield CameraModule.getAvailableVideoCodecs(this.handle, fileType);\n        } catch (e) {\n          throw tryParseNativeCameraError(e);\n        }\n      });\n      function getAvailableVideoCodecs(_x4) {\n        return _getAvailableVideoCodecs.apply(this, arguments);\n      }\n      return getAvailableVideoCodecs;\n    }()\n  }, {\n    key: \"onError\",\n    value: function onError(event) {\n      if (this.props.onError != null) {\n        var error = event.nativeEvent;\n        var cause = isErrorWithCause(error.cause) ? error.cause : undefined;\n        this.props.onError(new CameraRuntimeError(error.code, error.message, cause));\n      }\n    }\n  }, {\n    key: \"onInitialized\",\n    value: function onInitialized() {\n      var _this$props$onInitial, _this$props;\n      (_this$props$onInitial = (_this$props = this.props).onInitialized) === null || _this$props$onInitial === void 0 ? void 0 : _this$props$onInitial.call(_this$props);\n    }\n  }, {\n    key: \"onFrameProcessorPerformanceSuggestionAvailable\",\n    value: function onFrameProcessorPerformanceSuggestionAvailable(event) {\n      if (this.props.onFrameProcessorPerformanceSuggestionAvailable != null) this.props.onFrameProcessorPerformanceSuggestionAvailable(event.nativeEvent);\n    }\n  }, {\n    key: \"assertFrameProcessorsEnabled\",\n    value: function assertFrameProcessorsEnabled() {\n      if (global.setFrameProcessor == null || global.unsetFrameProcessor == null) {\n        throw new CameraRuntimeError('frame-processor/unavailable', 'Frame Processors are not enabled. See https://mrousavy.github.io/react-native-vision-camera/docs/guides/troubleshooting');\n      }\n    }\n  }, {\n    key: \"setFrameProcessor\",\n    value: function setFrameProcessor(frameProcessor) {\n      this.assertFrameProcessorsEnabled();\n      global.setFrameProcessor(this.handle, frameProcessor);\n    }\n  }, {\n    key: \"unsetFrameProcessor\",\n    value: function unsetFrameProcessor() {\n      this.assertFrameProcessorsEnabled();\n      global.unsetFrameProcessor(this.handle);\n    }\n  }, {\n    key: \"onViewReady\",\n    value: function onViewReady() {\n      this.isNativeViewMounted = true;\n      if (this.props.frameProcessor != null) {\n        this.setFrameProcessor(this.props.frameProcessor);\n        this.lastFrameProcessor = this.props.frameProcessor;\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      if (!this.isNativeViewMounted) return;\n      var frameProcessor = this.props.frameProcessor;\n      if (frameProcessor !== this.lastFrameProcessor) {\n        if (frameProcessor != null) this.setFrameProcessor(frameProcessor);else this.unsetFrameProcessor();\n        this.lastFrameProcessor = frameProcessor;\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props2 = this.props,\n        device = _this$props2.device,\n        frameProcessor = _this$props2.frameProcessor,\n        frameProcessorFps = _this$props2.frameProcessorFps,\n        props = _objectWithoutProperties(_this$props2, _excluded2);\n      return React.createElement(NativeCameraView, _extends({}, props, {\n        frameProcessorFps: frameProcessorFps === 'auto' ? -1 : frameProcessorFps,\n        cameraId: device.id,\n        ref: this.ref,\n        onViewReady: this.onViewReady,\n        onInitialized: this.onInitialized,\n        onError: this.onError,\n        onFrameProcessorPerformanceSuggestionAvailable: this.onFrameProcessorPerformanceSuggestionAvailable,\n        enableFrameProcessor: frameProcessor != null\n      }));\n    }\n  }], [{\n    key: \"getAvailableCameraDevices\",\n    value: function () {\n      var _getAvailableCameraDevices = _asyncToGenerator(function* () {\n        try {\n          return yield CameraModule.getAvailableCameraDevices();\n        } catch (e) {\n          throw tryParseNativeCameraError(e);\n        }\n      });\n      function getAvailableCameraDevices() {\n        return _getAvailableCameraDevices.apply(this, arguments);\n      }\n      return getAvailableCameraDevices;\n    }()\n  }, {\n    key: \"getCameraPermissionStatus\",\n    value: function () {\n      var _getCameraPermissionStatus = _asyncToGenerator(function* () {\n        try {\n          return yield CameraModule.getCameraPermissionStatus();\n        } catch (e) {\n          throw tryParseNativeCameraError(e);\n        }\n      });\n      function getCameraPermissionStatus() {\n        return _getCameraPermissionStatus.apply(this, arguments);\n      }\n      return getCameraPermissionStatus;\n    }()\n  }, {\n    key: \"getMicrophonePermissionStatus\",\n    value: function () {\n      var _getMicrophonePermissionStatus = _asyncToGenerator(function* () {\n        try {\n          return yield CameraModule.getMicrophonePermissionStatus();\n        } catch (e) {\n          throw tryParseNativeCameraError(e);\n        }\n      });\n      function getMicrophonePermissionStatus() {\n        return _getMicrophonePermissionStatus.apply(this, arguments);\n      }\n      return getMicrophonePermissionStatus;\n    }()\n  }, {\n    key: \"requestCameraPermission\",\n    value: function () {\n      var _requestCameraPermission = _asyncToGenerator(function* () {\n        try {\n          return yield CameraModule.requestCameraPermission();\n        } catch (e) {\n          throw tryParseNativeCameraError(e);\n        }\n      });\n      function requestCameraPermission() {\n        return _requestCameraPermission.apply(this, arguments);\n      }\n      return requestCameraPermission;\n    }()\n  }, {\n    key: \"requestMicrophonePermission\",\n    value: function () {\n      var _requestMicrophonePermission = _asyncToGenerator(function* () {\n        try {\n          return yield CameraModule.requestMicrophonePermission();\n        } catch (e) {\n          throw tryParseNativeCameraError(e);\n        }\n      });\n      function requestMicrophonePermission() {\n        return _requestMicrophonePermission.apply(this, arguments);\n      }\n      return requestMicrophonePermission;\n    }()\n  }]);\n  return Camera;\n}(React.PureComponent);\n_defineProperty(Camera, \"displayName\", 'Camera');\nvar NativeCameraView = requireNativeComponent('CameraView', Camera);","map":{"version":3,"mappings":"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","names":["React","requireNativeComponent","CameraCaptureError","CameraRuntimeError","tryParseNativeCameraError","isErrorWithCause","CameraModule","NativeModules","CameraView","console","error","Camera","constructor","props","_defineProperty","displayName","onViewReady","bind","onInitialized","onError","onFrameProcessorPerformanceSuggestionAvailable","ref","createRef","lastFrameProcessor","undefined","nodeHandle","findNodeHandle","current","options","takePhoto","handle","e","Platform","OS","takeSnapshot","startRecording","onRecordingError","onRecordingFinished","passThroughOptions","onRecordCallback","video","pauseRecording","resumeRecording","stopRecording","point","focus","fileType","getAvailableVideoCodecs","event","nativeEvent","cause","code","message","assertFrameProcessorsEnabled","global","setFrameProcessor","unsetFrameProcessor","frameProcessor","isNativeViewMounted","componentDidUpdate","render","device","frameProcessorFps","NativeCameraView","cameraId","id","enableFrameProcessor","getAvailableCameraDevices","getCameraPermissionStatus","getMicrophonePermissionStatus","requestCameraPermission","requestMicrophonePermission","PureComponent"],"sources":["Camera.tsx"],"sourcesContent":["import React from 'react';\nimport { requireNativeComponent, NativeModules, NativeSyntheticEvent, findNodeHandle, NativeMethods, Platform } from 'react-native';\nimport type { FrameProcessorPerformanceSuggestion, VideoFileType } from '.';\nimport type { CameraDevice } from './CameraDevice';\nimport type { ErrorWithCause } from './CameraError';\nimport { CameraCaptureError, CameraRuntimeError, tryParseNativeCameraError, isErrorWithCause } from './CameraError';\nimport type { CameraProps } from './CameraProps';\nimport type { Frame } from './Frame';\nimport type { PhotoFile, TakePhotoOptions } from './PhotoFile';\nimport type { Point } from './Point';\nimport type { TakeSnapshotOptions } from './Snapshot';\nimport type { CameraVideoCodec, RecordVideoOptions, VideoFile } from './VideoFile';\n\n//#region Types\nexport type CameraPermissionStatus = 'authorized' | 'not-determined' | 'denied' | 'restricted';\nexport type CameraPermissionRequestResult = 'authorized' | 'denied';\n\ninterface OnErrorEvent {\n  code: string;\n  message: string;\n  cause?: ErrorWithCause;\n}\ntype NativeCameraViewProps = Omit<\n  CameraProps,\n  'device' | 'onInitialized' | 'onError' | 'onFrameProcessorPerformanceSuggestionAvailable' | 'frameProcessor' | 'frameProcessorFps'\n> & {\n  cameraId: string;\n  frameProcessorFps?: number; // native cannot use number | string, so we use '-1' for 'auto'\n  enableFrameProcessor: boolean;\n  onInitialized?: (event: NativeSyntheticEvent<void>) => void;\n  onError?: (event: NativeSyntheticEvent<OnErrorEvent>) => void;\n  onFrameProcessorPerformanceSuggestionAvailable?: (event: NativeSyntheticEvent<FrameProcessorPerformanceSuggestion>) => void;\n  onViewReady: () => void;\n};\ntype RefType = React.Component<NativeCameraViewProps> & Readonly<NativeMethods>;\n//#endregion\n\n// NativeModules automatically resolves 'CameraView' to 'CameraViewModule'\n// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\nconst CameraModule = NativeModules.CameraView;\nif (CameraModule == null) console.error(\"Camera: Native Module 'CameraView' was null! Did you run pod install?\");\n\n//#region Camera Component\n/**\n * ### A powerful `<Camera>` component.\n *\n * Read the [VisionCamera documentation](https://mrousavy.github.io/react-native-vision-camera/) for more information.\n *\n * The `<Camera>` component's most important (and therefore _required_) properties are:\n *\n * * {@linkcode CameraProps.device | device}: Specifies the {@linkcode CameraDevice} to use. Get a {@linkcode CameraDevice} by using the {@linkcode useCameraDevices | useCameraDevices()} hook, or manually by using the {@linkcode Camera.getAvailableCameraDevices Camera.getAvailableCameraDevices()} function.\n * * {@linkcode CameraProps.isActive | isActive}: A boolean value that specifies whether the Camera should actively stream video frames or not. This can be compared to a Video component, where `isActive` specifies whether the video is paused or not. If you fully unmount the `<Camera>` component instead of using `isActive={false}`, the Camera will take a bit longer to start again.\n *\n * @example\n * ```tsx\n * function App() {\n *   const devices = useCameraDevices('wide-angle-camera')\n *   const device = devices.back\n *\n *   if (device == null) return <LoadingView />\n *   return (\n *     <Camera\n *       style={StyleSheet.absoluteFill}\n *       device={device}\n *       isActive={true}\n *     />\n *   )\n * }\n * ```\n *\n * @component\n */\nexport class Camera extends React.PureComponent<CameraProps> {\n  /** @internal */\n  static displayName = 'Camera';\n  /** @internal */\n  displayName = Camera.displayName;\n  private lastFrameProcessor: ((frame: Frame) => void) | undefined;\n  private isNativeViewMounted = false;\n\n  private readonly ref: React.RefObject<RefType>;\n\n  /** @internal */\n  constructor(props: CameraProps) {\n    super(props);\n    this.onViewReady = this.onViewReady.bind(this);\n    this.onInitialized = this.onInitialized.bind(this);\n    this.onError = this.onError.bind(this);\n    this.onFrameProcessorPerformanceSuggestionAvailable = this.onFrameProcessorPerformanceSuggestionAvailable.bind(this);\n    this.ref = React.createRef<RefType>();\n    this.lastFrameProcessor = undefined;\n  }\n\n  private get handle(): number | null {\n    const nodeHandle = findNodeHandle(this.ref.current);\n    if (nodeHandle == null || nodeHandle === -1) {\n      throw new CameraRuntimeError(\n        'system/view-not-found',\n        \"Could not get the Camera's native view tag! Does the Camera View exist in the native view-tree?\",\n      );\n    }\n\n    return nodeHandle;\n  }\n\n  //#region View-specific functions (UIViewManager)\n  /**\n   * Take a single photo and write it's content to a temporary file.\n   *\n   * @throws {@linkcode CameraCaptureError} When any kind of error occured while capturing the photo. Use the {@linkcode CameraCaptureError.code | code} property to get the actual error\n   * @example\n   * ```ts\n   * const photo = await camera.current.takePhoto({\n   *   qualityPrioritization: 'quality',\n   *   flash: 'on',\n   *   enableAutoRedEyeReduction: true\n   * })\n   * ```\n   */\n  public async takePhoto(options?: TakePhotoOptions): Promise<PhotoFile> {\n    try {\n      return await CameraModule.takePhoto(this.handle, options ?? {});\n    } catch (e) {\n      throw tryParseNativeCameraError(e);\n    }\n  }\n\n  /**\n   * Take a snapshot of the current preview view.\n   *\n   * This can be used as an alternative to {@linkcode Camera.takePhoto | takePhoto()} if speed is more important than quality\n   *\n   * @throws {@linkcode CameraCaptureError} When any kind of error occured while taking a snapshot. Use the {@linkcode CameraCaptureError.code | code} property to get the actual error\n   *\n   * @platform Android\n   * @example\n   * ```ts\n   * const photo = await camera.current.takeSnapshot({\n   *   quality: 85,\n   *   skipMetadata: true\n   * })\n   * ```\n   */\n  public async takeSnapshot(options?: TakeSnapshotOptions): Promise<PhotoFile> {\n    if (Platform.OS !== 'android')\n      throw new CameraCaptureError('capture/capture-type-not-supported', `'takeSnapshot()' is not available on ${Platform.OS}!`);\n\n    try {\n      return await CameraModule.takeSnapshot(this.handle, options ?? {});\n    } catch (e) {\n      throw tryParseNativeCameraError(e);\n    }\n  }\n\n  /**\n   * Start a new video recording.\n   *\n   * Records in the following formats:\n   * * **iOS**: QuickTime (`.mov`)\n   * * **Android**: MPEG4 (`.mp4`)\n   *\n   * @blocking This function is synchronized/blocking.\n   *\n   * @throws {@linkcode CameraCaptureError} When any kind of error occured while starting the video recording. Use the {@linkcode CameraCaptureError.code | code} property to get the actual error\n   *\n   * @example\n   * ```ts\n   * camera.current.startRecording({\n   *   onRecordingFinished: (video) => console.log(video),\n   *   onRecordingError: (error) => console.error(error),\n   * })\n   * setTimeout(() => {\n   *   camera.current.stopRecording()\n   * }, 5000)\n   * ```\n   */\n  public startRecording(options: RecordVideoOptions): void {\n    const { onRecordingError, onRecordingFinished, ...passThroughOptions } = options;\n    if (typeof onRecordingError !== 'function' || typeof onRecordingFinished !== 'function')\n      throw new CameraRuntimeError('parameter/invalid-parameter', 'The onRecordingError or onRecordingFinished functions were not set!');\n\n    const onRecordCallback = (video?: VideoFile, error?: CameraCaptureError): void => {\n      if (error != null) return onRecordingError(error);\n      if (video != null) return onRecordingFinished(video);\n    };\n    // TODO: Use TurboModules to either make this a sync invokation, or make it async.\n    try {\n      CameraModule.startRecording(this.handle, passThroughOptions, onRecordCallback);\n    } catch (e) {\n      throw tryParseNativeCameraError(e);\n    }\n  }\n\n  /**\n   * Pauses the current video recording.\n   *\n   * @throws {@linkcode CameraCaptureError} When any kind of error occured while pausing the video recording. Use the {@linkcode CameraCaptureError.code | code} property to get the actual error\n   *\n   * @example\n   * ```ts\n   * // Start\n   * await camera.current.startRecording()\n   * await timeout(1000)\n   * // Pause\n   * await camera.current.pauseRecording()\n   * await timeout(500)\n   * // Resume\n   * await camera.current.resumeRecording()\n   * await timeout(2000)\n   * // Stop\n   * const video = await camera.current.stopRecording()\n   * ```\n   */\n  public async pauseRecording(): Promise<void> {\n    try {\n      return await CameraModule.pauseRecording(this.handle);\n    } catch (e) {\n      throw tryParseNativeCameraError(e);\n    }\n  }\n\n  /**\n   * Resumes a currently paused video recording.\n   *\n   * @throws {@linkcode CameraCaptureError} When any kind of error occured while resuming the video recording. Use the {@linkcode CameraCaptureError.code | code} property to get the actual error\n   *\n   * @example\n   * ```ts\n   * // Start\n   * await camera.current.startRecording()\n   * await timeout(1000)\n   * // Pause\n   * await camera.current.pauseRecording()\n   * await timeout(500)\n   * // Resume\n   * await camera.current.resumeRecording()\n   * await timeout(2000)\n   * // Stop\n   * const video = await camera.current.stopRecording()\n   * ```\n   */\n  public async resumeRecording(): Promise<void> {\n    try {\n      return await CameraModule.resumeRecording(this.handle);\n    } catch (e) {\n      throw tryParseNativeCameraError(e);\n    }\n  }\n\n  /**\n   * Stop the current video recording.\n   *\n   * @throws {@linkcode CameraCaptureError} When any kind of error occured while stopping the video recording. Use the {@linkcode CameraCaptureError.code | code} property to get the actual error\n   *\n   * @example\n   * ```ts\n   * await camera.current.startRecording()\n   * setTimeout(async () => {\n   *  const video = await camera.current.stopRecording()\n   * }, 5000)\n   * ```\n   */\n  public async stopRecording(): Promise<void> {\n    try {\n      return await CameraModule.stopRecording(this.handle);\n    } catch (e) {\n      throw tryParseNativeCameraError(e);\n    }\n  }\n\n  /**\n   * Focus the camera to a specific point in the coordinate system.\n   * @param {Point} point The point to focus to. This should be relative to the Camera view's coordinate system,\n   * and expressed in Pixel on iOS and Points on Android.\n   *  * `(0, 0)` means **top left**.\n   *  * `(CameraView.width, CameraView.height)` means **bottom right**.\n   *\n   * Make sure the value doesn't exceed the CameraView's dimensions.\n   *\n   * @throws {@linkcode CameraRuntimeError} When any kind of error occured while focussing. Use the {@linkcode CameraRuntimeError.code | code} property to get the actual error\n   * @example\n   * ```ts\n   * await camera.current.focus({\n   *   x: tapEvent.x,\n   *   y: tapEvent.y\n   * })\n   * ```\n   */\n  public async focus(point: Point): Promise<void> {\n    try {\n      return await CameraModule.focus(this.handle, point);\n    } catch (e) {\n      throw tryParseNativeCameraError(e);\n    }\n  }\n  //#endregion\n\n  /**\n   * Get a list of video codecs the current camera supports for a given file type.  Returned values are ordered by efficiency (descending).\n   * @example\n   * ```ts\n   * const codecs = await camera.current.getAvailableVideoCodecs(\"mp4\")\n   * ```\n   * @throws {@linkcode CameraRuntimeError} When any kind of error occured while getting available video codecs. Use the {@linkcode ParameterError.code | code} property to get the actual error\n   * @platform iOS\n   */\n  public async getAvailableVideoCodecs(fileType?: VideoFileType): Promise<CameraVideoCodec[]> {\n    if (Platform.OS !== 'ios') return []; // no video codecs supported on other platforms.\n\n    try {\n      return await CameraModule.getAvailableVideoCodecs(this.handle, fileType);\n    } catch (e) {\n      throw tryParseNativeCameraError(e);\n    }\n  }\n\n  //#region Static Functions (NativeModule)\n  /**\n   * Get a list of all available camera devices on the current phone.\n   *\n   * @throws {@linkcode CameraRuntimeError} When any kind of error occured while getting all available camera devices. Use the {@linkcode CameraRuntimeError.code | code} property to get the actual error\n   * @example\n   * ```ts\n   * const devices = await Camera.getAvailableCameraDevices()\n   * const filtered = devices.filter((d) => matchesMyExpectations(d))\n   * const sorted = devices.sort(sortDevicesByAmountOfCameras)\n   * return {\n   *   back: sorted.find((d) => d.position === \"back\"),\n   *   front: sorted.find((d) => d.position === \"front\")\n   * }\n   * ```\n   */\n  public static async getAvailableCameraDevices(): Promise<CameraDevice[]> {\n    try {\n      return await CameraModule.getAvailableCameraDevices();\n    } catch (e) {\n      throw tryParseNativeCameraError(e);\n    }\n  }\n  /**\n   * Gets the current Camera Permission Status. Check this before mounting the Camera to ensure\n   * the user has permitted the app to use the camera.\n   *\n   * To actually prompt the user for camera permission, use {@linkcode Camera.requestCameraPermission | requestCameraPermission()}.\n   *\n   * @throws {@linkcode CameraRuntimeError} When any kind of error occured while getting the current permission status. Use the {@linkcode CameraRuntimeError.code | code} property to get the actual error\n   */\n  public static async getCameraPermissionStatus(): Promise<CameraPermissionStatus> {\n    try {\n      return await CameraModule.getCameraPermissionStatus();\n    } catch (e) {\n      throw tryParseNativeCameraError(e);\n    }\n  }\n  /**\n   * Gets the current Microphone-Recording Permission Status. Check this before mounting the Camera to ensure\n   * the user has permitted the app to use the microphone.\n   *\n   * To actually prompt the user for microphone permission, use {@linkcode Camera.requestMicrophonePermission | requestMicrophonePermission()}.\n   *\n   * @throws {@linkcode CameraRuntimeError} When any kind of error occured while getting the current permission status. Use the {@linkcode CameraRuntimeError.code | code} property to get the actual error\n   */\n  public static async getMicrophonePermissionStatus(): Promise<CameraPermissionStatus> {\n    try {\n      return await CameraModule.getMicrophonePermissionStatus();\n    } catch (e) {\n      throw tryParseNativeCameraError(e);\n    }\n  }\n  /**\n   * Shows a \"request permission\" alert to the user, and resolves with the new camera permission status.\n   *\n   * If the user has previously blocked the app from using the camera, the alert will not be shown\n   * and `\"denied\"` will be returned.\n   *\n   * @throws {@linkcode CameraRuntimeError} When any kind of error occured while requesting permission. Use the {@linkcode CameraRuntimeError.code | code} property to get the actual error\n   */\n  public static async requestCameraPermission(): Promise<CameraPermissionRequestResult> {\n    try {\n      return await CameraModule.requestCameraPermission();\n    } catch (e) {\n      throw tryParseNativeCameraError(e);\n    }\n  }\n  /**\n   * Shows a \"request permission\" alert to the user, and resolves with the new microphone permission status.\n   *\n   * If the user has previously blocked the app from using the microphone, the alert will not be shown\n   * and `\"denied\"` will be returned.\n   *\n   * @throws {@linkcode CameraRuntimeError} When any kind of error occured while requesting permission. Use the {@linkcode CameraRuntimeError.code | code} property to get the actual error\n   */\n  public static async requestMicrophonePermission(): Promise<CameraPermissionRequestResult> {\n    try {\n      return await CameraModule.requestMicrophonePermission();\n    } catch (e) {\n      throw tryParseNativeCameraError(e);\n    }\n  }\n  //#endregion\n\n  //#region Events (Wrapped to maintain reference equality)\n  private onError(event: NativeSyntheticEvent<OnErrorEvent>): void {\n    if (this.props.onError != null) {\n      const error = event.nativeEvent;\n      const cause = isErrorWithCause(error.cause) ? error.cause : undefined;\n      this.props.onError(\n        // @ts-expect-error We're casting from unknown bridge types to TS unions, I expect it to hopefully work\n        new CameraRuntimeError(error.code, error.message, cause),\n      );\n    }\n  }\n\n  private onInitialized(): void {\n    this.props.onInitialized?.();\n  }\n\n  private onFrameProcessorPerformanceSuggestionAvailable(event: NativeSyntheticEvent<FrameProcessorPerformanceSuggestion>): void {\n    if (this.props.onFrameProcessorPerformanceSuggestionAvailable != null)\n      this.props.onFrameProcessorPerformanceSuggestionAvailable(event.nativeEvent);\n  }\n  //#endregion\n\n  //#region Lifecycle\n  /** @internal */\n  private assertFrameProcessorsEnabled(): void {\n    // @ts-expect-error JSI functions aren't typed\n    if (global.setFrameProcessor == null || global.unsetFrameProcessor == null) {\n      throw new CameraRuntimeError(\n        'frame-processor/unavailable',\n        'Frame Processors are not enabled. See https://mrousavy.github.io/react-native-vision-camera/docs/guides/troubleshooting',\n      );\n    }\n  }\n\n  private setFrameProcessor(frameProcessor: (frame: Frame) => void): void {\n    this.assertFrameProcessorsEnabled();\n    // @ts-expect-error JSI functions aren't typed\n    global.setFrameProcessor(this.handle, frameProcessor);\n  }\n\n  private unsetFrameProcessor(): void {\n    this.assertFrameProcessorsEnabled();\n    // @ts-expect-error JSI functions aren't typed\n    global.unsetFrameProcessor(this.handle);\n  }\n\n  private onViewReady(): void {\n    this.isNativeViewMounted = true;\n    if (this.props.frameProcessor != null) {\n      // user passed a `frameProcessor` but we didn't set it yet because the native view was not mounted yet. set it now.\n      this.setFrameProcessor(this.props.frameProcessor);\n      this.lastFrameProcessor = this.props.frameProcessor;\n    }\n  }\n\n  /** @internal */\n  componentDidUpdate(): void {\n    if (!this.isNativeViewMounted) return;\n    const frameProcessor = this.props.frameProcessor;\n    if (frameProcessor !== this.lastFrameProcessor) {\n      // frameProcessor argument identity changed. Update native to reflect the change.\n      if (frameProcessor != null) this.setFrameProcessor(frameProcessor);\n      else this.unsetFrameProcessor();\n\n      this.lastFrameProcessor = frameProcessor;\n    }\n  }\n  //#endregion\n\n  /** @internal */\n  public render(): React.ReactNode {\n    // We remove the big `device` object from the props because we only need to pass `cameraId` to native.\n    const { device, frameProcessor, frameProcessorFps, ...props } = this.props;\n    return (\n      <NativeCameraView\n        {...props}\n        frameProcessorFps={frameProcessorFps === 'auto' ? -1 : frameProcessorFps}\n        cameraId={device.id}\n        ref={this.ref}\n        onViewReady={this.onViewReady}\n        onInitialized={this.onInitialized}\n        onError={this.onError}\n        onFrameProcessorPerformanceSuggestionAvailable={this.onFrameProcessorPerformanceSuggestionAvailable}\n        enableFrameProcessor={frameProcessor != null}\n      />\n    );\n  }\n}\n//#endregion\n\n// requireNativeComponent automatically resolves 'CameraView' to 'CameraViewManager'\nconst NativeCameraView = requireNativeComponent<NativeCameraViewProps>(\n  'CameraView',\n  // @ts-expect-error because the type declarations are kinda wrong, no?\n  Camera,\n);\n"]},"metadata":{},"sourceType":"module"}